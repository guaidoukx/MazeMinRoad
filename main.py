import pandas as pdimport numpy as npimport randomdef get_legal_moves(present_position):    x = present_position[0]    y = present_position[1]    legal_moves = []    reachable_array = ReachableMatrix[x][y]    # print(reachable_array)    if reachable_array[0]:        if y > 0:            legal_moves.append([x, y-1])    if reachable_array[1]:        if x < mx - 1:            legal_moves.append([x+1, y])    if reachable_array[2]:        if y < my - 1:            legal_moves.append([x, y+1])    if reachable_array[3]:        if x > 0:            legal_moves.append([x-1, y])    return legal_moves    def get_max_qvalue_move_and_value(present_position):    # print(present_position[0], present_position[1])    legal_moves = get_legal_moves(present_position)    max_value = 0    index = 0    for ind, move in enumerate(legal_moves):        x = move[0]        y = move[1]        if QMatrix[x][y] is not None:            value = QMatrix[x][y]            if value > max_value:                max_value = value                index = ind    if max_value == 0:        if len(legal_moves) == 1:            index = 0        else:            index = random.randint(0, len(legal_moves)-1)    # print("get_max_qvalue_move_and_value: ")    # print(legal_moves[index][0], legal_moves[index][1], max_value)    # print("\n")    return legal_moves[index], max_value    def get_move(present_position):    legal_moves = get_legal_moves(present_position)    if random.random() < epsilon:        return legal_moves[random.randint(0, len(legal_moves)-1)]    else:        return get_max_qvalue_move_and_value(present_position)[0]    def update(present_position):    ax = present_position[0]    ay = present_position[1]    move = get_move(present_position)    next_position = [0, 0]    next_position[0] = move[0]    next_position[1] = move[1]    print(next_position)    x = move[0]    y = move[1]    # 判断下一步是否已经到终点，确定reward的值    reward = (x == target_position[0] and y == target_position[1])    qvalue = QMatrix[ax][ay]    old_qvalue = 0 if (qvalue == -100) else qvalue    new_value = old_qvalue + alpha * (reward + gamma * get_max_qvalue_move_and_value(present_position)[1] - old_qvalue)    QMatrix[x][y] = new_value    return next_position        if __name__ == '__main__':    # 输入 图像的结构化数据表示    result = pd.read_csv('mazeCsv.tsv', sep='\t')    mx = 52    my = 29        epsilon = 0.5    epsilonDecay = 0.0001    gamma = 0.92    alpha = 0.1    target_position = [51, 28]    agent_position = []        ReachableMatrix = np.zeros((mx, my, 4))    for i in range(len(result)):        c = 0        for j in range(4):            ReachableMatrix[result.iloc[i][1]][result.iloc[i][0]][j] = result.iloc[i][j + 2]            if result.iloc[i][j + 2] == 1:                c = c+1        if c == 0:            print(i)    QMatrix = np.zeros((mx, my))    for i in range(mx):        for j in range(my):            QMatrix[i][j] = -100    print("start to train ...")    max = 100    made_count = 0    game_count = 0    while game_count < max:        if game_count % (max / 100) == 0:            print("Epoch: %d / %d  " % (game_count, max))        start_position = [random.randint(0, mx-1), random.randint(0, my-1)]        agent_position = start_position        moves = []        walkCount = 0        while True:            move = get_move(agent_position)            moves.append(move)            walkCount = walkCount + 1            agent_position = update(agent_position)            if agent_position[0] == target_position[0] and agent_position[1] == target_position[1]:                break            if walkCount > 3 * mx * my:                break        game_count = game_count + 1        if agent_position[0] == target_position[0] and agent_position[1] == target_position[1]:            made_count = made_count + 1            epsilon = epsilon - epsilonDecay                count = 0    for i in range(mx):        for j in range(my):            if QMatrix[i][j] != -100:                count = count+1                print(QMatrix[i][j])    print(count)    print(QMatrix)